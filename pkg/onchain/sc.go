package onchain

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/massalabs/station/pkg/node"
	sendOperation "github.com/massalabs/station/pkg/node/sendoperation"
	"github.com/massalabs/station/pkg/node/sendoperation/callsc"
	"github.com/massalabs/station/pkg/node/sendoperation/executesc"
	"github.com/massalabs/station/pkg/node/sendoperation/signer"
)

const maxWaitingTimeInSeconds = 45

const evenHeartbeat = 2

type OperationWithEventResponse struct {
	Event             string
	OperationResponse sendOperation.OperationResponse
}

// CallFunction calls a function of a smart contract on the blockchain. It returns the event generated
// by the smart contract and an Error.
// If `async` is true, it returns the operation response and does not wait for the event.
// Otherwise, it waits for the first event generated by the smart contract and returns it.
//
// Note: Listening to the first event generated by the smart contract should be done by the front end,
// but for now, it is done here to match the previous implementation.
func CallFunction(client *node.Client,
	nickname string,
	addr string,
	function string,
	parameter []byte,
	coins uint64,
	expiryDelta uint64,
	async bool,
	operationBatch sendOperation.OperationBatch,
	signer signer.Signer,
) (*OperationWithEventResponse, error) {
	callSC, err := callsc.New(addr, function, parameter,
		sendOperation.DefaultGasLimit,
		coins)

	if err != nil {
		return nil, fmt.Errorf("creating callSC with '%s' at '%s': %w", function, addr, err)
	}

	operationResponse, err := sendOperation.Call(
		client,
		expiryDelta, sendOperation.NoFee,
		callSC,
		nickname,
		operationBatch,
		signer,
	)

	if err != nil {
		return nil, fmt.Errorf("calling function '%s' at '%s' with '%+v': %w", function, addr, parameter, err)
	}

	if async {
		return &OperationWithEventResponse{
			Event:             "Function called successfully but did not wait for event",
			OperationResponse: *operationResponse,
		}, nil
	}

	eventFound, operationWithEventResponse, err := listenEvents(client, operationResponse)
	if eventFound {
		return operationWithEventResponse, err
	}

	return &OperationWithEventResponse{
		Event:             "Function called successfully but no event generated",
		OperationResponse: *operationResponse,
	}, nil
}

// DeploySC deploys a smart contract on the blockchain. It returns the address of the smart contract and an Error.
// The smart contract is deployed with the given account nickname.
func DeploySC(client *node.Client,
	nickname string,
	gasLimit uint64,
	coins uint64,
	fee uint64,
	expiry uint64,
	contract []byte,
	datastore []byte,
	operationBatch sendOperation.OperationBatch,
	signer signer.Signer,
) (*OperationWithEventResponse, error) {
	exeSC := executesc.New(
		contract,
		gasLimit,
		coins,
		datastore)

	operationResponse, err := sendOperation.Call(
		client,
		expiry,
		fee,
		exeSC,
		nickname,
		operationBatch,
		signer,
	)
	if err != nil {
		return nil, fmt.Errorf("calling executeSC: %w", err)
	}

	eventFound, operationWithEventResponse, err := listenEvents(client, operationResponse)
	if eventFound {
		return operationWithEventResponse, err
	}

	// If no event received, return a message to announce sc is deployed
	return &OperationWithEventResponse{
		Event:             "sc deployed successfully but no event received",
		OperationResponse: *operationResponse,
	}, nil
}

func listenEvents(
	client *node.Client,
	operationResponse *sendOperation.OperationResponse,
) (bool, *OperationWithEventResponse, error) {
	counter := 0

	ticker := time.NewTicker(time.Second * evenHeartbeat)

	for ; true; <-ticker.C {
		counter++

		if counter > maxWaitingTimeInSeconds*evenHeartbeat {
			break
		}

		events, err := node.Events(client, nil, nil, nil, nil, &operationResponse.OperationID)
		if err != nil {
			return true, nil, fmt.Errorf("waiting SC deployment: %w", err)
		}

		if len(events) > 0 {
			event := events[0].Data

			// Catch Run Time Error and return it
			if strings.Contains(event, "massa_execution_error") {
				// return the event containing the error
				return true, nil, errors.New(event)
			}

			// if there is an event, return the first event
			return true, &OperationWithEventResponse{
				Event:             event,
				OperationResponse: *operationResponse,
			}, nil
		}
	}

	return false, nil, nil
}
