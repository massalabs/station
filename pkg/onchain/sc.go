package onchain

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/massalabs/station/pkg/node"
	sendOperation "github.com/massalabs/station/pkg/node/sendoperation"
	"github.com/massalabs/station/pkg/node/sendoperation/callsc"
	"github.com/massalabs/station/pkg/node/sendoperation/executesc"
	"github.com/massalabs/station/pkg/node/sendoperation/signer"
)

const maxWaitingTimeInSeconds = 45

const pollIntervalSec = 1

type OperationWithEventResponse struct {
	Event             string
	OperationResponse sendOperation.OperationResponse
}

// CallFunction calls a function of a smart contract on the blockchain. It returns the operation ID or an Error if any.
// If `async` is true, it returns directly the operation ID and does not wait for the event.
// Otherwise, it waits for the first event generated by the smart contract and returns it along with the operation ID.
func CallFunction(client *node.Client,
	nickname string,
	addr string,
	function string,
	parameter []byte,
	coins uint64,
	expiryDelta uint64,
	async bool,
	operationBatch sendOperation.OperationBatch,
	signer signer.Signer,
) (*OperationWithEventResponse, error) {
	callSC, err := callsc.New(addr, function, parameter,
		sendOperation.DefaultGasLimit,
		coins)
	if err != nil {
		return nil, fmt.Errorf("creating callSC with '%s' at '%s': %w", function, addr, err)
	}

	operationResponse, err := sendOperation.Call(
		client,
		expiryDelta,
		sendOperation.DefaultFee,
		callSC,
		nickname,
		operationBatch,
		signer,
	)
	if err != nil {
		return nil, fmt.Errorf("calling function '%s' at '%s' with '%+v': %w", function, addr, parameter, err)
	}

	if async {
		return &OperationWithEventResponse{
			Event:             "Function called successfully but did not wait for event",
			OperationResponse: *operationResponse,
		}, nil
	}

	events, err := listenEvents(client, operationResponse.OperationID)
	if err != nil {
		if strings.Contains(err.Error(), "Timeout") {
			return &OperationWithEventResponse{
				Event:             "Operation submited successfully but no event generated. The operation may have been rejected",
				OperationResponse: *operationResponse,
			}, nil
		}

		return nil, err
	}

	// return first event
	// TO DO: return all events
	return &OperationWithEventResponse{
		Event:             events[0].Data,
		OperationResponse: *operationResponse,
	}, nil
}

// DeploySC deploys a smart contract on the blockchain. It returns the address of the smart contract and an Error.
// The smart contract is deployed with the given account nickname.
func DeploySC(client *node.Client,
	nickname string,
	gasLimit uint64,
	maxCoins uint64,
	fee uint64,
	expiry uint64,
	contract []byte,
	datastore []byte,
	operationBatch sendOperation.OperationBatch,
	signer signer.Signer,
) (*sendOperation.OperationResponse, []node.Event, error) {
	exeSC := executesc.New(
		contract,
		gasLimit,
		maxCoins,
		datastore)

	operationResponse, err := sendOperation.Call(
		client,
		expiry,
		fee,
		exeSC,
		nickname,
		operationBatch,
		signer,
	)
	if err != nil {
		return nil, nil, fmt.Errorf("calling executeSC: %w", err)
	}

	events, err := listenEvents(client, operationResponse.OperationID)
	if err != nil {
		return nil, nil, err
	}

	return operationResponse, events, nil
}

func listenEvents(
	client *node.Client,
	operationID string,
) ([]node.Event, error) {
	counter := 0

	ticker := time.NewTicker(time.Second * pollIntervalSec)

	for ; true; <-ticker.C {
		counter++

		if counter > maxWaitingTimeInSeconds/pollIntervalSec {
			break
		}

		events, err := node.Events(client, nil, nil, nil, nil, &operationID)
		if err != nil {
			return nil, fmt.Errorf("fetching events for opId %s: %w", operationID, err)
		}

		for _, event := range events {
			if strings.Contains(event.Data, "massa_execution_error") {
				// return the event containing the error
				return nil, errors.New(event.Data)
			}
		}

		if len(events) > 0 {
			return events, nil
		}
	}

	return nil, fmt.Errorf("listening events for opId %s: Timeout", operationID)
}

func FindDeployedAddress(events []node.Event) (string, bool) {
	pattern := "Contract deployed at address: (.+)"
	re := regexp.MustCompile(pattern)

	for _, event := range events {
		match := re.FindStringSubmatch(event.Data)
		if len(match) > 1 {
			return match[1], true
		}
	}

	return "", false
}
