//
// Copyright (c) 2018 Konstantin Ivanov <kostyarin.ivanov@gmail.com>.
// All rights reserved. This program is free software. It comes without
// any warranty, to the extent permitted by applicable law. You can
// redistribute it and/or modify it under the terms of the Do What
// The Fuck You Want To Public License, Version 2, as published by
// Sam Hocevar. See LICENSE file for more details or see below.
//

//
//        DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
//                    Version 2, December 2004
//
// Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
//
// Everyone is permitted to copy and distribute verbatim or modified
// copies of this license document, and changing it is allowed as long
// as the name is changed.
//
//            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
//   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
//
//  0. You just DO WHAT THE FUCK YOU WANT TO.
//

// Package textFileToGoConst implements go:generate tool to put
// a text file to string constant of your Go project.
//
// Commandline flags and arguments
//
//     -in     - source file name (required)
//     -o      - output file name (defaults to source + .go)
//     -p      - package name (defaults to autodetect)
//     -c      - constant name (defaults to CamelCased file name without dots)
//     -no-gat - no 'generated at' time
//     -h      - show help
//
// Example go:generate comments
//
//     //go:generate textFileToGoConst -in=lua/get.lua
//     //go:generate textFileToGoConst -in=lua/set.lua -o=setLua.go -c=setLua
//     //go:generate textFileToGoConst -in=init.lua github.com/example/goProject
//
package wallet

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"
)

func init() {
	log.SetFlags(0)
}

func generateFile(in string) {
	var (
		out   string
		cnst  string
		nogat bool
		help  bool
		pkg   string // package name
	)

	flag.StringVar(&in,
		"in",
		in,
		"source file name")
	flag.StringVar(&out,
		"o",
		out,
		"output file name (defaults to source + .go)")
	flag.StringVar(&pkg,
		"p",
		pkg,
		"package name (defaults to autodetect)")
	flag.StringVar(&cnst,
		"c",
		cnst,
		"constant name (defaults to CamelCased file name without dots)")
	flag.BoolVar(&nogat,
		"no-gat",
		false,
		"don't put 'generated at' line")
	flag.BoolVar(&help,
		"h",
		false,
		"show help")
	flag.Parse()

	if help == true {
		log.Println(fmt.Sprintf(
			"Use %s <flags> [directory]",
			os.Args[0]))
		flag.PrintDefaults()
		return
	}

	if in == "" {
		log.Fatal("'in' flag required")
	}
	var args = flag.Args()

	if len(args) == 0 {
		args = []string{"."}
	} else if len(args) == 1 {
		if isDirectory(args[0]) == false {
			log.Fatal("command line argument is not a directory")
		}
	} else {
		log.Fatal("too many command line arguments")
	}

	var (
		dir = args[0] // output directory
		err error
	)

	// autodetect package name if necessary
	if pkg == "" {
		if pkg, err = getPackageName(dir); err != nil {
			log.Fatal("can't detect golang package name")
		}
	}

	if filepath.IsAbs(in) == false {
		in = filepath.Join(dir, in)
	}

	// read file
	var b []byte

	b, err = ioutil.ReadFile(in)
	if err != nil {
		log.Fatal(err)
	}

	var outFile = new(bytes.Buffer)

	writeLine(outFile, "// GENERATED BY textFileToGoConst")
	writeLine(outFile,
		"// GitHub:     github.com/logrusorgru/textFileToGoConst")
	writeLine(outFile, "// input file: "+in)
	if !nogat {
		writeLine(outFile, "// generated:  "+time.Now().Format(time.UnixDate))
	}
	writeLine(outFile, "")
	writeLine(outFile, "package wallet")
	writeLine(outFile, "")

	// constant name by input file name
	if cnst == "" {
		cnst = constNameByFileName(strings.Title(in)) // get.lua => getLua
	}

	outFile.WriteString(fmt.Sprintf("const %s = ", cnst))

	if sb := string(b); canBackquote(sb) == true {
		outFile.WriteRune('`')
		outFile.Write(b)
		outFile.WriteRune('`')
	} else {
		outFile.WriteString(strconv.Quote(sb))
	}

	writeLine(outFile, "")

	// output file name and location

	if out == "" {
		out = "../../pkg/wallet/" + filepath.Base(in) + ".go"
	}

	if filepath.IsAbs(out) == false {
		out = filepath.Join(dir, out)
	}

	err = ioutil.WriteFile(out, outFile.Bytes(), 0644)

	if err != nil {
		log.Fatal(err)
	}

	// Success!
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ExitOnError)
}

func canBackquote(sb string) bool {
	return strings.Contains(sb, "`") == false
}

func constNameByFileName(fileName string) string {
	fileName = filepath.Base(fileName)
	var ss = strings.Split(fileName, ".")
	if len(ss) == 1 {
		return ss[0]
	}
	for i := 1; i < len(ss); i++ {
		ss[i] = upperCaseFirst(ss[i])
	}
	return strings.Join(ss, "")
}

func upperCaseFirst(val string) string {
	if len(val) == 0 {
		return val // not changed
	}
	var r, w = utf8.DecodeRuneInString(val)
	if w == 0 {
		return val // not changed
	}
	return string(unicode.ToUpper(r)) + val[w:]
}

// with \n or \r\n depending on OS
func writeLine(outFile *bytes.Buffer, line string) {
	outFile.WriteString(fmt.Sprintln(line))
}

func getPackageName(dir string) (name string, err error) {
	var pkg *build.Package
	if pkg, err = build.Default.ImportDir(dir, 0); err != nil {
		return
	}
	name = pkg.Name
	return
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func GenerateFiles() {
	generateFile("../../pkg/wallet/index.css")
	generateFile("../../pkg/wallet/index.html")
	generateFile("../../pkg/wallet/index.js")
	generateFile("../../pkg/wallet/logo_massa.webp")
}

// go:generate textFileToGoConst -in=get.lua -no-gat
